<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Dual Screen Presenter with Gemini Vision</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="preconnect" href="https://fonts.googleapis.com">

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">

    <style>

        body {

            font-family: 'Inter', sans-serif;

        }

        /* Custom scrollbar for a cleaner look in the textarea */

        textarea::-webkit-scrollbar {

            width: 8px;

        }

        textarea::-webkit-scrollbar-track {

            background: #1f2937;

        }

        textarea::-webkit-scrollbar-thumb {

            background-color: #4b5563;

            border-radius: 20px;

            border: 3px solid #1f2937;

        }

        /* Simple loading spinner */

        .loader {

            border: 4px solid #f3f3f3;

            border-radius: 50%;

            border-top: 4px solid #4f46e5;

            width: 24px;

            height: 24px;

            animation: spin 1s linear infinite;

        }

        @keyframes spin {

            0% { transform: rotate(0deg); }

            100% { transform: rotate(360deg); }

        }

        /* API Status Indicator */

        .status-light {

            width: 12px;

            height: 12px;

            border-radius: 50%;

            display: inline-block;

            margin-right: 8px;

            flex-shrink: 0;

        }

        .status-idle { background-color: #9ca3af; }

        .status-checking { background-color: #f59e0b; }

        .status-ok { background-color: #22c55e; }

        .status-error { background-color: #ef4444; }

        

        /* Scrolling Names Animation */

        .scrolling-names-container {

            width: 100%;

            overflow: hidden;

            white-space: nowrap;

        }

        .scrolling-names-list {

            display: inline-block;

            animation: scroll-left linear infinite;

        }

        @keyframes scroll-left {

            from {

                transform: translateX(0%);

            }

            to {

                transform: translateX(-50%);

            }

        }

    </style>

</head>

<body class="bg-gray-900 text-gray-100 antialiased">



    <!-- Launcher View -->

    <div id="launcher" class="min-h-screen flex flex-col justify-center items-center p-4 text-center">

        <div class="max-w-2xl mx-auto">

            <svg class="mx-auto h-16 w-16 text-indigo-400 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">

              <path stroke-linecap="round" stroke-linejoin="round" d="M9 17.25v1.007a3 3 0 01-.879 2.122L7.5 21h9l-1.621-.621A3 3 0 0115 18.257V17.25m6-12V15a2.25 2.25 0 01-2.25 2.25H5.25A2.25 2.25 0 013 15V5.25A2.25 2.25 0 015.25 3h9.75a2.25 2.25 0 012.25 2.25z" />

            </svg>

            <h1 class="text-4xl md:text-5xl font-bold text-white tracking-tight">Dual Screen Presenter</h1>

            <p class="mt-4 text-lg text-gray-400">Control a presentation on a second screen. Now with <span class="font-bold text-indigo-400">Gemini Vision</span> to transcribe text from images.</p>

            

            <div class="mt-8 w-full max-w-md mx-auto bg-gray-800/50 border border-gray-700 rounded-lg p-4 text-left">

                <label for="api-key-input" class="block text-sm font-medium text-gray-200 mb-2">Google Gemini API Key</label>

                <div class="flex gap-2">

                    <input type="password" id="api-key-input" class="flex-grow bg-gray-900 border border-gray-600 rounded-md px-3 py-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500" placeholder="Enter your API key">

                    <button id="save-key-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-md transition-colors">Save & Check</button>

                </div>

                <div id="api-status-container" class="mt-3 flex items-start">

                    <div id="api-status-light" class="status-light status-idle mt-1"></div>

                    <span id="api-status-text" class="text-gray-400 text-sm">Enter your API key to check the connection.</span>

                </div>

            </div>



            <div class="mt-8">

                <h2 class="text-xl font-semibold text-white">How to Use:</h2>

                <ol class="list-decimal list-inside text-left mt-4 text-gray-300 space-y-2 max-w-md mx-auto">

                    <li>Enter and save your Google Gemini API key above.</li>

                    <li>Connect your laptop to a second display and "Extend" your desktop.</li>

                    <li>Click "Open Display Screen", drag the new window to the second monitor, and make it full-screen (F11).</li>

                    <li>Use the "Controller" screen to type, upload, drag & drop, or capture an image for transcription.</li>

                </ol>

            </div>



            <div class="mt-12 flex flex-col sm:flex-row gap-4 justify-center">

                <button id="openControllerBtn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-indigo-500">

                    Open Controller Screen

                </button>

                <button id="openDisplayBtn" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-transform transform hover:scale-105 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-900 focus:ring-gray-500">

                    Open Display Screen

                </button>

            </div>

        </div>

    </div>



    <!-- Controller View -->

    <div id="controller" class="hidden h-screen flex flex-col p-4 relative">

        <div id="drop-zone-overlay" class="absolute inset-0 bg-gray-900/80 border-4 border-dashed border-indigo-500 rounded-lg flex-col justify-center items-center text-2xl font-bold text-white hidden z-10">

            <svg class="w-16 h-16 mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 16.5V9.75m0 0l-3 3m3-3l3-3M6.75 19.5a4.5 4.5 0 01-1.41-8.775 5.25 5.25 0 0110.233-2.33 3 3 0 013.758 3.848A3.752 3.752 0 0118 19.5H6.75z" /></svg>

            <span>Drop image here to transcribe</span>

        </div>



        <div class="flex-shrink-0 mb-4 flex justify-between items-center">

             <div class="flex-1">

                <h1 class="text-2xl font-bold text-center text-indigo-400">Controller Screen</h1>

                <p class="text-sm text-center text-gray-500">Type, upload, drag & drop, or capture an image to transcribe.</p>

             </div>

             <button id="settings-btn" class="text-gray-400 hover:text-white p-2">

                <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.438.995s.145.755.438.995l1.003.827c.48.398.668 1.03.26 1.431l-1.296 2.247a1.125 1.125 0 01-1.37.49l-1.217-.456c-.355-.133-.75-.072-1.075.124a6.57 6.57 0 01-.22.127c-.332.183-.582.495-.645.87l-.213 1.281c-.09.543-.56.94-1.11.94h-2.593c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.063-.374-.313-.686-.645-.87a6.52 6.52 0 01-.22-.127c-.324-.196-.72-.257-1.075-.124l-1.217.456a1.125 1.125 0 01-1.37-.49l-1.296-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.437-.995s-.145-.755-.437-.995l-1.004-.827a1.125 1.125 0 01-.26-1.431l1.296-2.247a1.125 1.125 0 011.37-.49l1.217.456c.355.133.75.072 1.075-.124.072-.044.146-.087.22-.127.332-.183.582-.495.645-.87l.213-1.281z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>

             </button>

        </div>

        

        <div class="mb-4 flex justify-between items-center">

            <div class="border-b border-gray-700">

                <nav class="-mb-px flex space-x-8" aria-label="Tabs">

                    <button id="tab-file" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-indigo-500 text-indigo-400">File Input</button>

                    <button id="tab-camera" class="whitespace-nowrap py-4 px-1 border-b-2 font-medium text-sm border-transparent text-gray-400 hover:text-gray-200 hover:border-gray-500">Camera Input</button>

                </nav>

            </div>

            <div class="flex items-center gap-2">

                <label for="name-mode-toggle" class="text-sm font-medium text-gray-300">Multiple Name Mode</label>

                <input type="checkbox" id="name-mode-toggle" class="h-6 w-10 rounded-full bg-gray-600 checked:bg-indigo-500 appearance-none ring-2 ring-transparent focus:outline-none focus:ring-indigo-500 transition-colors">

            </div>

        </div>



        <div id="panel-file" class="bg-gray-800 p-4 rounded-lg mb-4 border border-gray-700">

            <div class="flex items-center justify-between">

                <div class="flex items-center gap-4">

                    <label for="image-upload" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg cursor-pointer transition-colors">Choose Image</label>

                    <input type="file" id="image-upload" class="hidden" accept="image/*">

                    <span id="file-name" class="text-gray-400 italic">No file chosen</span>

                </div>

                <button id="transcribe-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-2 px-4 rounded-lg disabled:bg-gray-500 disabled:cursor-not-allowed flex items-center gap-2" disabled>

                    <span id="transcribe-btn-text">Transcribe</span>

                    <div id="loader" class="loader hidden"></div>

                </button>

            </div>

        </div>



        <div id="panel-camera" class="hidden bg-gray-800 p-4 rounded-lg mb-4 border border-gray-700">

            <div class="mb-4">

                <label for="camera-select" class="block text-sm font-medium text-gray-300">Select Camera:</label>

                <select id="camera-select" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-white"></select>

            </div>

            <div class="flex flex-col md:flex-row gap-4 items-center">

                <div class="w-full md:w-1/2 bg-black rounded-lg overflow-hidden aspect-video">

                    <video id="camera-feed" class="w-full h-full object-cover" autoplay playsinline></video>

                </div>

                <div class="flex flex-col items-center gap-4">

                    <button id="capture-btn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-2 px-6 rounded-lg flex items-center gap-2">

                        <svg class="w-6 h-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M6.827 6.175A2.31 2.31 0 015.186 7.23c-.38.054-.757.112-1.134.175C2.999 7.58 2.25 8.507 2.25 9.574V18a2.25 2.25 0 002.25 2.25h15A2.25 2.25 0 0021.75 18V9.574c0-1.067-.75-1.994-1.802-2.169a47.865 47.865 0 00-1.134-.175 2.31 2.31 0 01-1.64-1.055l-.822-1.316a2.192 2.192 0 00-1.736-1.039 48.776 48.776 0 00-5.232 0 2.192 2.192 0 00-1.736 1.039l-.821 1.316z" /><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 12.75a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0zM18.75 10.5h.008v.008h-.008V10.5z" /></svg>

                        <span>Capture & Transcribe</span>

                    </button>

                    <div id="capture-loader" class="loader hidden"></div>

                </div>

            </div>

        </div>

        <canvas id="canvas" class="hidden"></canvas>



        <div id="name-list-panel" class="flex flex-col flex-grow mb-4">

            <div class="flex justify-between items-center mb-2">

                <h3 class="text-lg font-semibold text-white">Scanned Names</h3>

                <button id="clear-names-btn" class="text-sm text-red-400 hover:text-red-300">Clear List</button>

            </div>

            <div id="name-list-container" class="flex-grow bg-gray-800 border-2 border-gray-700 rounded-lg p-4 text-gray-200 overflow-y-auto"></div>

            <div class="mt-2 flex gap-2">

                <input type="text" id="add-name-input" class="flex-grow bg-gray-700 border border-gray-600 rounded-md p-2 text-white" placeholder="Add name manually...">

                <button id="add-name-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-md">Add</button>

            </div>

        </div>



        <div id="error-message" class="text-red-400 mb-2 text-sm text-center"></div>

        <textarea id="text-input" class="w-full h-24 bg-gray-800 border-2 border-gray-700 rounded-lg p-4 text-xl text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 resize-none" placeholder="Last scanned name or manual text..."></textarea>

    </div>



    <!-- Settings Modal -->

    <div id="settings-modal" class="hidden fixed inset-0 bg-gray-900/80 z-20 flex justify-center items-center p-4">

        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-2xl border border-gray-700 divide-y divide-gray-700">

            <div class="p-6">

                <h2 class="text-xl font-bold text-white mb-4">Transcription Settings</h2>

                <label for="prompt-input" class="block text-sm font-medium text-gray-300 mb-2">Gemini System Prompt</label>

                <textarea id="prompt-input" rows="4" class="w-full bg-gray-900 border border-gray-600 rounded-md p-2 text-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500"></textarea>

                <p class="text-xs text-gray-500 mt-1">This is the instruction sent to the AI with every image.</p>

            </div>

            <div class="p-6">

                <h2 class="text-xl font-bold text-white mb-4">Display Background</h2>

                <label for="background-upload" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg cursor-pointer transition-colors inline-block">Choose Background Image</label>

                <input type="file" id="background-upload" class="hidden" accept="image/*">

                <span id="background-file-name" class="text-gray-400 italic ml-4">No file chosen</span>

                <p class="text-xs text-gray-500 mt-2">The background will be saved and applied to the display screen.</p>

                <button id="remove-background-btn" class="mt-2 text-sm text-red-400 hover:text-red-300">Remove Background</button>

            </div>

             <div class="p-6">

                <h2 class="text-xl font-bold text-white mb-4">Display Font</h2>

                <div class="space-y-4">

                    <div>

                        <label for="font-upload" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg cursor-pointer transition-colors inline-block">Choose Font File</label>

                        <input type="file" id="font-upload" class="hidden" accept=".ttf,.otf,.woff,.woff2">

                        <span id="font-file-name" class="text-gray-400 italic ml-4">No file chosen</span>

                        <p class="text-xs text-gray-500 mt-2">Upload a custom font (.ttf, .otf, .woff) for the display screen.</p>

                        <button id="remove-font-btn" class="mt-2 text-sm text-red-400 hover:text-red-300">Reset to Default Font</button>

                    </div>

                    <div class="grid grid-cols-2 gap-4">

                        <div>

                            <label for="font-weight-select" class="block text-sm font-medium text-gray-300">Font Weight</label>

                            <select id="font-weight-select" class="mt-1 block w-full bg-gray-700 border border-gray-600 rounded-md shadow-sm py-2 px-3 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm text-white">

                                <option value="normal">Normal</option>

                                <option value="bold">Bold</option>

                            </select>

                        </div>

                        <div>

                            <label for="text-shadow-toggle" class="block text-sm font-medium text-gray-300">Text Shadow</label>

                            <input type="checkbox" id="text-shadow-toggle" class="mt-2 h-6 w-10 rounded-full bg-gray-600 checked:bg-indigo-500 appearance-none ring-2 ring-transparent focus:outline-none focus:ring-indigo-500 transition-colors">

                        </div>

                    </div>

                </div>

            </div>

            <div class="bg-gray-700/50 px-6 py-3 flex justify-end gap-4">

                <button id="close-settings-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-4 rounded-md">Close</button>

                <button id="save-settings-btn" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-2 px-4 rounded-md">Save Settings</button>

            </div>

        </div>

    </div>



    <!-- Display View -->

    <div id="display" class="hidden h-screen flex justify-center items-center bg-black bg-cover bg-center overflow-hidden">

        <!-- Standard Text Mode -->

        <div id="display-standard-mode" class="w-full h-full flex justify-center items-center bg-black/30 p-10">

            <div id="display-text" class="text-white text-4xl md:text-6xl lg:text-8xl font-bold text-center break-words w-full">

                Waiting for content...

            </div>

        </div>

        <!-- Multiple Name Mode -->

        <div id="display-name-mode" class="hidden w-full h-full flex flex-col items-center justify-center bg-black/30 p-10 text-4xl md:text-6xl lg:text-8xl text-white">

            <div id="display-welcome-text" class="mb-4">Hoş Geldiniz!</div>

            <div class="scrolling-names-container">

                <div id="scrolling-names-list" class="scrolling-names-list"></div>

            </div>

        </div>

    </div>



    <script>

        // --- DOM Elements ---

        const launcher = document.getElementById('launcher');

        const controller = document.getElementById('controller');

        const display = document.getElementById('display');

        

        const openControllerBtn = document.getElementById('openControllerBtn');

        const openDisplayBtn = document.getElementById('openDisplayBtn');

        const textInput = document.getElementById('text-input');

        const displayText = document.getElementById('display-text');



        const imageUpload = document.getElementById('image-upload');

        const fileName = document.getElementById('file-name');

        const transcribeBtn = document.getElementById('transcribe-btn');

        const transcribeBtnText = document.getElementById('transcribe-btn-text');

        const loader = document.getElementById('loader');

        const errorMessage = document.getElementById('error-message');

        

        const apiKeyInput = document.getElementById('api-key-input');

        const saveKeyBtn = document.getElementById('save-key-btn');

        const apiStatusLight = document.getElementById('api-status-light');

        const apiStatusText = document.getElementById('api-status-text');



        const dropZoneOverlay = document.getElementById('drop-zone-overlay');



        const tabFile = document.getElementById('tab-file');

        const tabCamera = document.getElementById('tab-camera');

        const panelFile = document.getElementById('panel-file');

        const panelCamera = document.getElementById('panel-camera');

        const cameraSelect = document.getElementById('camera-select');

        const cameraFeed = document.getElementById('camera-feed');

        const captureBtn = document.getElementById('capture-btn');

        const captureLoader = document.getElementById('capture-loader');

        const canvas = document.getElementById('canvas');

        let cameraStream = null;



        // Settings Modal Elements

        const settingsBtn = document.getElementById('settings-btn');

        const settingsModal = document.getElementById('settings-modal');

        const closeSettingsBtn = document.getElementById('close-settings-btn');

        const saveSettingsBtn = document.getElementById('save-settings-btn');

        const promptInput = document.getElementById('prompt-input');

        const backgroundUpload = document.getElementById('background-upload');

        const backgroundFileName = document.getElementById('background-file-name');

        const removeBackgroundBtn = document.getElementById('remove-background-btn');

        const fontUpload = document.getElementById('font-upload');

        const fontFileName = document.getElementById('font-file-name');

        const removeFontBtn = document.getElementById('remove-font-btn');

        const fontWeightSelect = document.getElementById('font-weight-select');

        const textShadowToggle = document.getElementById('text-shadow-toggle');

        let tempBackgroundData = null;

        let tempFontData = null;

        let tempFontName = null;



        // Multiple Name Mode Elements

        const nameModeToggle = document.getElementById('name-mode-toggle');

        const nameListPanel = document.getElementById('name-list-panel');

        const nameListContainer = document.getElementById('name-list-container');

        const clearNamesBtn = document.getElementById('clear-names-btn');

        const addNameInput = document.getElementById('add-name-input');

        const addNameBtn = document.getElementById('add-name-btn');

        const displayStandardMode = document.getElementById('display-standard-mode');

        const displayNameMode = document.getElementById('display-name-mode');

        const scrollingNamesList = document.getElementById('scrolling-names-list');

        const displayWelcomeText = document.getElementById('display-welcome-text');



        let selectedFile = null;



        // --- Constants ---

        const STORAGE_KEY_TEXT = 'dualScreenPresenterText';

        const STORAGE_KEY_API = 'dualScreenPresenterApiKey';

        const STORAGE_KEY_PROMPT = 'dualScreenPresenterPrompt';

        const STORAGE_KEY_BACKGROUND = 'dualScreenPresenterBackground';

        const STORAGE_KEY_FONT = 'dualScreenPresenterFont';

        const STORAGE_KEY_FONT_NAME = 'dualScreenPresenterFontName';

        const STORAGE_KEY_FONT_WEIGHT = 'dualScreenPresenterFontWeight';

        const STORAGE_KEY_TEXT_SHADOW = 'dualScreenPresenterTextShadow';

        const STORAGE_KEY_NAME_MODE = 'dualScreenPresenterNameMode';

        const STORAGE_KEY_NAME_LIST = 'dualScreenPresenterNameList';

        const DEFAULT_PROMPT = `Transcribe the text from the image and return a JSON object with "message", "name", and "surname" fields. The "message" should be in the format "Hoş geldin, [name] [surname]!". If no name is found, return a JSON object where "message" is "Hoş geldiniz!", and "name" and "surname" are empty strings.`;

        

        // --- Functions ---

        function showView(viewToShow) {

            launcher.classList.add('hidden');

            controller.classList.add('hidden');

            display.classList.add('hidden');

            viewToShow.classList.remove('hidden');

        }



        function updateDisplay() {

            const currentText = localStorage.getItem(STORAGE_KEY_TEXT);

            if (displayText) {

                displayText.innerHTML = currentText ? currentText.replace(/\n/g, '<br>') : 'Waiting for content...';

            }

        }

        

        function applyCustomFont() {

            const fontData = localStorage.getItem(STORAGE_KEY_FONT);

            const fontName = localStorage.getItem(STORAGE_KEY_FONT_NAME);

            const styleId = 'custom-font-style';

            let styleElement = document.getElementById(styleId);

            const elementsToStyle = [displayText, displayWelcomeText, scrollingNamesList];



            if (fontData && fontName) {

                if (!styleElement) {

                    styleElement = document.createElement('style');

                    styleElement.id = styleId;

                    document.head.appendChild(styleElement);

                }

                styleElement.innerHTML = `

                    @font-face {

                        font-family: 'CustomPresenterFont';

                        src: url(${fontData});

                    }

                `;

                elementsToStyle.forEach(el => { if(el) el.style.fontFamily = 'CustomPresenterFont, sans-serif'; });

            } else {

                if (styleElement) styleElement.remove();

                elementsToStyle.forEach(el => { if(el) el.style.fontFamily = "'Inter', sans-serif"; });

            }

        }

        

        function applyFontStyles() {

            const fontWeight = localStorage.getItem(STORAGE_KEY_FONT_WEIGHT) || 'bold';

            const textShadow = localStorage.getItem(STORAGE_KEY_TEXT_SHADOW) === 'true';

            const elementsToStyle = [displayText, displayWelcomeText, scrollingNamesList];



            elementsToStyle.forEach(el => {

                if(el) {

                    el.style.fontWeight = fontWeight;

                    el.style.textShadow = textShadow ? '2px 2px 8px rgba(0,0,0,0.8)' : 'none';

                }

            });

        }



        function updateBackground() {

            const bgData = localStorage.getItem(STORAGE_KEY_BACKGROUND);

            if (display) {

                 if (bgData) {

                    display.style.backgroundImage = `url(${bgData})`;

                } else {

                    display.style.backgroundImage = 'none';

                }

            }

        }

        

        function loadControllerState() {

            const currentText = localStorage.getItem(STORAGE_KEY_TEXT);

            if (textInput) textInput.value = currentText || '';

            

            const savedPrompt = localStorage.getItem(STORAGE_KEY_PROMPT) || DEFAULT_PROMPT;

            if(promptInput) promptInput.value = savedPrompt;



            const savedFontName = localStorage.getItem(STORAGE_KEY_FONT_NAME);

            if(fontFileName) fontFileName.textContent = savedFontName || 'No file chosen';



            const savedWeight = localStorage.getItem(STORAGE_KEY_FONT_WEIGHT) || 'bold';

            if(fontWeightSelect) fontWeightSelect.value = savedWeight;



            const savedShadow = localStorage.getItem(STORAGE_KEY_TEXT_SHADOW) === 'true';

            if(textShadowToggle) textShadowToggle.checked = savedShadow;



            const nameMode = localStorage.getItem(STORAGE_KEY_NAME_MODE) === 'true';

            if(nameModeToggle) nameModeToggle.checked = nameMode;

            renderControllerNameList();

        }



        function fileToBase64(file) {

            return new Promise((resolve, reject) => {

                const reader = new FileReader();

                reader.readAsDataURL(file);

                reader.onload = () => resolve(reader.result);

                reader.onerror = error => reject(error);

            });

        }

        

        async function checkApiKey() {

            const apiKey = localStorage.getItem(STORAGE_KEY_API);

            if (!apiKey) {

                 apiStatusLight.className = 'status-light status-idle';

                 apiStatusText.textContent = 'Enter your API key to check the connection.';

                 return;

            }

            

            apiStatusLight.className = 'status-light status-checking';

            apiStatusText.textContent = 'Checking API Key...';

            

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const payload = { contents: [{ parts: [{ text: "hello" }] }] };



            try {

                const response = await fetch(apiUrl, {

                    method: 'POST',

                    headers: { 'Content-Type': 'application/json' },

                    body: JSON.stringify(payload)

                });



                if (response.ok) {

                    apiStatusLight.className = 'status-light status-ok';

                    apiStatusText.textContent = 'API Connection Successful!';

                } else {

                    const error = await response.json();

                    throw new Error(error.error.message);

                }

            } catch (error) {

                console.error("API Key Check Failed:", error);

                apiStatusLight.className = 'status-light status-error';

                if (error.message.includes("API key not valid")) {

                    apiStatusText.innerHTML = '<strong>API Key is not valid.</strong> Please check the key and try again.';

                } else if (error.message.includes("blocked")) {

                    apiStatusText.innerHTML = `<strong>API requests are blocked.</strong> This is likely a configuration issue. Please ensure the "Generative Language API" (or Gemini API) is enabled in your Google Cloud project.`;

                } else {

                    apiStatusText.innerHTML = `<strong>API Connection Failed.</strong> Please check your network connection and console for details.`;

                }

            }

        }



        async function callGeminiApi(base64ImageData, mimeType) {

            const apiKey = localStorage.getItem(STORAGE_KEY_API);

            if (!apiKey) throw new Error("API Key is not set. Please set it on the launcher page.");



            const userPrompt = localStorage.getItem(STORAGE_KEY_PROMPT) || DEFAULT_PROMPT;

            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            

            const payload = {

                contents: [{

                    parts: [

                        { text: userPrompt },

                        { inlineData: { mimeType: mimeType, data: base64ImageData.split(',')[1] } }

                    ]

                }],

            };



            let response;

            let delay = 1000;

            for (let i = 0; i < 4; i++) {

                try {

                    response = await fetch(apiUrl, {

                        method: 'POST',

                        headers: { 'Content-Type': 'application/json' },

                        body: JSON.stringify(payload)

                    });



                    if (response.ok) {

                        const result = await response.json();

                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;

                        try {

                            // Clean the response to make it valid JSON

                            const cleanText = text.replace(/```json\n|```/g, '').trim();

                            return JSON.parse(cleanText);

                        } catch (e) {

                            console.error("Failed to parse Gemini response as JSON:", text);

                            // Fallback for non-JSON responses

                            return { message: text, name: "", surname: "" };

                        }

                    } else if (response.status === 429 || response.status >= 500) {

                        await new Promise(resolve => setTimeout(resolve, delay));

                        delay *= 2;

                    } else {

                        const errorResult = await response.json();

                        throw new Error(`API Error: ${errorResult.error?.message || response.statusText}`);

                    }

                } catch (error) {

                    if (i === 3) throw error;

                }

            }

            throw new Error('Failed to get response from Gemini API after multiple retries.');

        }



        async function triggerTranscription(file) {

             if (!file || !file.type.startsWith('image/')) {

                errorMessage.textContent = 'Please provide a valid image file.';

                return;

            }



            selectedFile = file;

            fileName.textContent = selectedFile.name;

            transcribeBtn.disabled = true;

            loader.classList.remove('hidden');

            transcribeBtnText.textContent = 'Transcribing...';

            errorMessage.textContent = '';



            try {

                const base64Image = await fileToBase64(selectedFile);

                const transcriptionResult = await callGeminiApi(base64Image, selectedFile.type);



                // Update the main text area with the full message

                textInput.value = transcriptionResult.message;

                localStorage.setItem(STORAGE_KEY_TEXT, transcriptionResult.message);

                

                // Add to the unified list if a name was found

                if (transcriptionResult.name && transcriptionResult.surname) {

                    const fullName = `${transcriptionResult.name} ${transcriptionResult.surname}`.trim();

                    const names = JSON.parse(localStorage.getItem(STORAGE_KEY_NAME_LIST) || '[]');

                    names.push(fullName);

                    localStorage.setItem(STORAGE_KEY_NAME_LIST, JSON.stringify(names));

                    renderControllerNameList();

                }



            } catch (error) {

                console.error('Transcription failed:', error);

                errorMessage.textContent = `Error: ${error.message}`;

            } finally {

                transcribeBtn.disabled = false;

                loader.classList.add('hidden');

                transcribeBtnText.textContent = 'Transcribe';

            }

        }



        async function getCameras() {

            try {

                await navigator.mediaDevices.getUserMedia({ video: true });

                const devices = await navigator.mediaDevices.enumerateDevices();

                const videoDevices = devices.filter(device => device.kind === 'videoinput');

                

                cameraSelect.innerHTML = '';

                if (videoDevices.length === 0) {

                    errorMessage.textContent = "No cameras found.";

                    return;

                }



                videoDevices.forEach((device, index) => {

                    const option = document.createElement('option');

                    option.value = device.deviceId;

                    option.text = device.label || `Camera ${index + 1}`;

                    cameraSelect.appendChild(option);

                });

                startCamera(videoDevices[0].deviceId);

            } catch (err) {

                 console.error("Error getting cameras: ", err);

                 errorMessage.textContent = "Could not access camera. Please ensure you have a camera connected and have granted permission.";

            }

        }



        async function startCamera(deviceId) {

            try {

                if (cameraStream) cameraStream.getTracks().forEach(track => track.stop());

                const constraints = { video: { deviceId: deviceId ? { exact: deviceId } : undefined } };

                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);

                cameraFeed.srcObject = cameraStream;

            } catch (err) {

                console.error("Error accessing camera: ", err);

                errorMessage.textContent = "Could not access camera. Please ensure you have a camera connected and have granted permission.";

            }

        }



        function stopCamera() {

            if (cameraStream) {

                cameraStream.getTracks().forEach(track => track.stop());

                cameraFeed.srcObject = null;

            }

        }

        

        function renderControllerNameList() {

            const names = JSON.parse(localStorage.getItem(STORAGE_KEY_NAME_LIST) || '[]');

            if (nameListContainer) {

                nameListContainer.innerHTML = ''; // Clear previous list

                names.forEach((name, index) => {

                    const itemContainer = document.createElement('div');

                    itemContainer.className = 'flex items-center gap-2 mb-2';



                    const nameInput = document.createElement('input');

                    nameInput.type = 'text';

                    nameInput.value = name;

                    nameInput.dataset.index = index;

                    nameInput.className = 'flex-grow bg-gray-700 border border-gray-600 rounded-md p-2 text-white';

                    nameInput.addEventListener('change', (e) => {

                        const updatedNames = JSON.parse(localStorage.getItem(STORAGE_KEY_NAME_LIST) || '[]');

                        updatedNames[e.target.dataset.index] = e.target.value;

                        localStorage.setItem(STORAGE_KEY_NAME_LIST, JSON.stringify(updatedNames));

                    });



                    const deleteBtn = document.createElement('button');

                    deleteBtn.innerHTML = '&#x2715;'; // X character

                    deleteBtn.className = 'text-red-400 hover:text-red-300 font-bold';

                    deleteBtn.dataset.index = index;

                    deleteBtn.addEventListener('click', (e) => {

                        const updatedNames = JSON.parse(localStorage.getItem(STORAGE_KEY_NAME_LIST) || '[]');

                        updatedNames.splice(e.target.dataset.index, 1);

                        localStorage.setItem(STORAGE_KEY_NAME_LIST, JSON.stringify(updatedNames));

                        renderControllerNameList();

                    });



                    itemContainer.appendChild(nameInput);

                    itemContainer.appendChild(deleteBtn);

                    nameListContainer.appendChild(itemContainer);

                });

            }

        }



        function setupDisplayMode() {

            const isNameMode = localStorage.getItem(STORAGE_KEY_NAME_MODE) === 'true';

            if (isNameMode) {

                displayStandardMode.classList.add('hidden');

                displayNameMode.classList.remove('hidden');

                renderScrollingNameList();

            } else {

                displayStandardMode.classList.remove('hidden');

                displayNameMode.classList.add('hidden');

            }

        }



        function renderScrollingNameList() {

            const names = JSON.parse(localStorage.getItem(STORAGE_KEY_NAME_LIST) || '[]');

            if (scrollingNamesList) {

                if (names.length === 0) {

                    scrollingNamesList.innerHTML = '';

                    return;

                }

                const firstNames = names.map(name => name.split(' ')[0]);

                

                // Repeat the list 10 times

                const repeatedFirstNames = Array(10).fill(firstNames).flat();

                const scrollText = repeatedFirstNames.join('&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');

                

                // Duplicate for seamless loop

                scrollingNamesList.innerHTML = `${scrollText}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;${scrollText}`;

                

                // Adjust animation duration based on content length

                const duration = repeatedFirstNames.length * 5; // 5 seconds per name

                scrollingNamesList.style.animationDuration = `${duration}s`;

            }

        }



        // --- Event Listeners ---

        if (openControllerBtn) openControllerBtn.onclick = () => window.open(window.location.pathname + '#controller', '_blank');

        if (openDisplayBtn) openDisplayBtn.onclick = () => window.open(window.location.pathname + '#display', '_blank');

        if (textInput) textInput.addEventListener('input', () => localStorage.setItem(STORAGE_KEY_TEXT, textInput.value));

        

        if (imageUpload) {

            imageUpload.addEventListener('change', (event) => {

                const file = event.target.files[0];

                if (file) {

                    selectedFile = file;

                    fileName.textContent = selectedFile.name;

                    transcribeBtn.disabled = false;

                    errorMessage.textContent = '';

                }

            });

        }

        

        if (transcribeBtn) {

            transcribeBtn.addEventListener('click', () => {

                if (selectedFile) triggerTranscription(selectedFile); 

            });

        }



        window.addEventListener('storage', (event) => { 

            if (event.key === STORAGE_KEY_TEXT) updateDisplay();

            if (event.key === STORAGE_KEY_BACKGROUND) updateBackground();

            if (event.key === STORAGE_KEY_FONT || event.key === STORAGE_KEY_FONT_WEIGHT || event.key === STORAGE_KEY_TEXT_SHADOW) {

                applyCustomFont();

                applyFontStyles();

            }

            if (event.key === STORAGE_KEY_NAME_MODE) setupDisplayMode();

            if (event.key === STORAGE_KEY_NAME_LIST) {

                renderScrollingNameList();

                renderControllerNameList();

            }

        });

        

        if (saveKeyBtn) {

            saveKeyBtn.addEventListener('click', () => {

                const key = apiKeyInput.value.trim();

                if (key) {

                    localStorage.setItem(STORAGE_KEY_API, key);

                    checkApiKey();

                }

            });

        }



        if (controller) {

            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => controller.addEventListener(eventName, e => { e.preventDefault(); e.stopPropagation(); }));

            ['dragenter', 'dragover'].forEach(eventName => controller.addEventListener(eventName, () => { dropZoneOverlay.classList.remove('hidden'); dropZoneOverlay.classList.add('flex'); }));

            ['dragleave', 'drop'].forEach(eventName => controller.addEventListener(eventName, () => { dropZoneOverlay.classList.add('hidden'); dropZoneOverlay.classList.remove('flex'); }));

            controller.addEventListener('drop', (e) => { 

                const files = e.dataTransfer.files;

                if (files.length > 0) triggerTranscription(files[0]);

            });

        }



        if (tabFile) {

            tabFile.addEventListener('click', () => {

                panelFile.classList.remove('hidden'); panelCamera.classList.add('hidden');

                tabFile.classList.add('border-indigo-500', 'text-indigo-400'); tabFile.classList.remove('border-transparent', 'text-gray-400');

                tabCamera.classList.add('border-transparent', 'text-gray-400'); tabCamera.classList.remove('border-indigo-500', 'text-indigo-400');

                stopCamera();

            });

        }

        if (tabCamera) {

            tabCamera.addEventListener('click', () => {

                panelCamera.classList.remove('hidden'); panelFile.classList.add('hidden');

                tabCamera.classList.add('border-indigo-500', 'text-indigo-400'); tabCamera.classList.remove('border-transparent', 'text-gray-400');

                tabFile.classList.add('border-transparent', 'text-gray-400'); tabFile.classList.remove('border-indigo-500', 'text-indigo-400');

                getCameras();

            });

        }

        if (cameraSelect) cameraSelect.addEventListener('change', (event) => startCamera(event.target.value));

        

        if (captureBtn) {

            captureBtn.addEventListener('click', async () => {

                captureBtn.disabled = true; captureLoader.classList.remove('hidden'); errorMessage.textContent = '';

                try {

                    canvas.width = cameraFeed.videoWidth; canvas.height = cameraFeed.videoHeight;

                    const context = canvas.getContext('2d');

                    context.drawImage(cameraFeed, 0, 0, canvas.width, canvas.height);

                    const mimeType = 'image/jpeg';

                    const base64Image = canvas.toDataURL(mimeType);

                    const transcriptionResult = await callGeminiApi(base64Image, mimeType);

                    

                    textInput.value = transcriptionResult.message;

                    localStorage.setItem(STORAGE_KEY_TEXT, transcriptionResult.message);



                    if (transcriptionResult.name && transcriptionResult.surname) {

                        const fullName = `${transcriptionResult.name} ${transcriptionResult.surname}`.trim();

                        const names = JSON.parse(localStorage.getItem(STORAGE_KEY_NAME_LIST) || '[]');

                        names.push(fullName);

                        localStorage.setItem(STORAGE_KEY_NAME_LIST, JSON.stringify(names));

                        renderControllerNameList();

                    }



                } catch (error) {

                    console.error('Capture and Transcribe failed:', error);

                    errorMessage.textContent = `Error: ${error.message}`;

                } finally {

                    captureBtn.disabled = false; captureLoader.classList.add('hidden');

                }

            });

        }



        // --- Settings Modal Listeners ---

        if (settingsBtn) settingsBtn.addEventListener('click', () => settingsModal.classList.remove('hidden'));

        if (closeSettingsBtn) closeSettingsBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));

        if (saveSettingsBtn) {

            saveSettingsBtn.addEventListener('click', () => {

                localStorage.setItem(STORAGE_KEY_PROMPT, promptInput.value);

                localStorage.setItem(STORAGE_KEY_FONT_WEIGHT, fontWeightSelect.value);

                localStorage.setItem(STORAGE_KEY_TEXT_SHADOW, textShadowToggle.checked);



                if (tempBackgroundData) {

                    localStorage.setItem(STORAGE_KEY_BACKGROUND, tempBackgroundData);

                    tempBackgroundData = null;

                }

                if (tempFontData && tempFontName) {

                    localStorage.setItem(STORAGE_KEY_FONT, tempFontData);

                    localStorage.setItem(STORAGE_KEY_FONT_NAME, tempFontName);

                    tempFontData = null;

                    tempFontName = null;

                }

                settingsModal.classList.add('hidden');

            });

        }

        if (backgroundUpload) {

            backgroundUpload.addEventListener('change', async (event) => {

                const file = event.target.files[0];

                if (file) {

                    backgroundFileName.textContent = file.name;

                    tempBackgroundData = await fileToBase64(file);

                }

            });

        }

        if (removeBackgroundBtn) {

            removeBackgroundBtn.addEventListener('click', () => {

                localStorage.removeItem(STORAGE_KEY_BACKGROUND);

                backgroundFileName.textContent = 'No file chosen';

                tempBackgroundData = null;

            });

        }

        if (fontUpload) {

            fontUpload.addEventListener('change', async (event) => {

                const file = event.target.files[0];

                if(file) {

                    fontFileName.textContent = file.name;

                    tempFontData = await fileToBase64(file);

                    tempFontName = file.name;

                }

            });

        }

        if (removeFontBtn) {

            removeFontBtn.addEventListener('click', () => {

                localStorage.removeItem(STORAGE_KEY_FONT);

                localStorage.removeItem(STORAGE_KEY_FONT_NAME);

                fontFileName.textContent = 'No file chosen';

                tempFontData = null;

                tempFontName = null;

            });

        }

        if (nameModeToggle) {

            nameModeToggle.addEventListener('change', (e) => {

                const isEnabled = e.target.checked;

                localStorage.setItem(STORAGE_KEY_NAME_MODE, isEnabled);

            });

        }

        if (clearNamesBtn) {

            clearNamesBtn.addEventListener('click', () => {

                localStorage.setItem(STORAGE_KEY_NAME_LIST, '[]');

                renderControllerNameList();

            });

        }

        if (addNameBtn) {

            addNameBtn.addEventListener('click', () => {

                const newName = addNameInput.value.trim();

                if (newName) {

                    const names = JSON.parse(localStorage.getItem(STORAGE_KEY_NAME_LIST) || '[]');

                    names.push(newName);

                    localStorage.setItem(STORAGE_KEY_NAME_LIST, JSON.stringify(names));

                    renderControllerNameList();

                    addNameInput.value = '';

                }

            });

        }





        // --- Page Load Logic ---

        document.addEventListener('DOMContentLoaded', () => {

            const hash = window.location.hash;

            if (hash === '#controller') {

                showView(controller);

                loadControllerState();

            } else if (hash === '#display') {

                showView(display);

                updateDisplay();

                updateBackground();

                applyCustomFont();

                applyFontStyles();

                setupDisplayMode();

            } else {

                showView(launcher);

                const savedKey = localStorage.getItem(STORAGE_KEY_API);

                if (savedKey) {

                    apiKeyInput.value = savedKey;

                    checkApiKey();

                }

            }

        });



    </script>

</body>

</html>

